{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "33917da8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Please enter the required value: enc or dec ::enc\n",
      "Please enter the 8-bit string to be encrypted or decrypted (in 0's and 1's)::01000101\n",
      "Please enter the 10-bit key value(in 0's and 1's)::0110100111\n",
      "Cipher Text is:: 01001100\n"
     ]
    }
   ],
   "source": [
    "#Symmetric Encryption\n",
    "\"\"\"Symmetric Encryption\n",
    "   The following stand-alone program demonstrate symmetric encryption which encloses the functionalites\n",
    "   of Key Generation( Key1 & Key2), encryption & decryption\"\"\"\n",
    "\n",
    "\n",
    "def p_8_10_order(input_key , order = 10):\n",
    "    \"\"\"This method arranges the input in the order specified i.e., P-10 or P-8 as per parameters passed\"\"\"\n",
    "    new_string = \"r\"\n",
    "    flag = False\n",
    "    if order == 10:\n",
    "        p_order = \"35274101986\"\n",
    "    else:\n",
    "        p_order = \"637485109\"\n",
    "    for digit in p_order:\n",
    "        if digit == '0':\n",
    "            pass\n",
    "        elif digit =='1': \n",
    "            if flag == False:\n",
    "                current_char_index = p_order.index(digit)\n",
    "                if p_order[current_char_index+1] == '0':\n",
    "                    new_string+=input_key[9]\n",
    "                    flag = True\n",
    "            else:\n",
    "                new_string+=input_key[int(digit)-1]\n",
    "        else:\n",
    "            new_string+= input_key[int(digit)-1]\n",
    "    return new_string\n",
    "\n",
    "def input_encryption(arrangement,input_key):\n",
    "    \"\"\"This method arranges the input in the order specified i.e., IP or EP OR P-4 OR IP inverse, as per \n",
    "    parameters passed\"\"\"\n",
    "    new_string = ''\n",
    "    if arrangement =='i_p':\n",
    "        enc_permutation = '26314857'\n",
    "    elif arrangement == 'e_p':\n",
    "        enc_permutation = '41232341'\n",
    "    elif arrangement == 'p_4':\n",
    "        enc_permutation = '2431'\n",
    "    else:\n",
    "        enc_permutation = '41357286'\n",
    "    for digit in enc_permutation:\n",
    "        new_string+= input_key[int(digit)-1]\n",
    "    return new_string\n",
    "\n",
    "def split_shift(rearranged_string, shift=1):\n",
    "    \"\"\"This method splits and left shifts by 1 or 2 places and concatenates the shifted bits!\"\"\"\n",
    "    left_bit = rearranged_string[1:6]\n",
    "    right_bit = rearranged_string[6:11]\n",
    "    if shift == 1:\n",
    "        left_shifted_left_bit = left_bit[1:5]+left_bit[0]\n",
    "        left_shifted_right_bit = right_bit[1:5]+right_bit[0]\n",
    "    else:\n",
    "        left_shifted_left_bit = left_bit[2:5]+left_bit[0:2]\n",
    "        left_shifted_right_bit = right_bit[2:5]+right_bit[0:2]\n",
    "    f_shifted_bit = left_shifted_left_bit + left_shifted_right_bit\n",
    "    return f_shifted_bit\n",
    "\n",
    "def xor_with_value(e_p_arranged_order, key):\n",
    "    \"\"\"This method performs xor operation!\"\"\"\n",
    "    xored_string=''\n",
    "    for index in range(len(key)):\n",
    "        if e_p_arranged_order[index] == key[index]:\n",
    "            xored_string+='0'\n",
    "        else:\n",
    "            xored_string+='1'\n",
    "    return xored_string\n",
    "\n",
    "def get_binary_value(binary_decimal_dictionary, value):\n",
    "    \"\"\"This method performs decimal to binary conversion and returns binary value!\"\"\"\n",
    "    for binary_value, decimal_value in binary_decimal_dictionary.items():\n",
    "        if decimal_value == value:\n",
    "            return binary_value\n",
    "        \n",
    "def divide_into_bits_s0_s1_mapping(xored_string):\n",
    "    \"\"\"This method divides the xor string into first and second bits and maps it to s0 and s1 table\n",
    "    and returns the concatenated string\"\"\"\n",
    "    s0=[[1,0,3,2],\n",
    "        [3,2,1,0],\n",
    "        [0,2,1,3],\n",
    "        [3,1,3,2]]\n",
    "  \n",
    "    s1=[[0,1,2,3],\n",
    "        [2,0,1,3],\n",
    "        [3,0,1,0],\n",
    "        [2,1,0,3]]\n",
    "\n",
    "    binary_decimal_dictionary = {\"00\":0,\"01\":1,\"10\":2,\"11\":3}\n",
    "    first_half = xored_string[0:4]\n",
    "    second_half = xored_string[4:]\n",
    "    s0_row = first_half[0]+first_half[-1]\n",
    "    s0_column = first_half[1]+first_half[2]\n",
    "    s0_row_decimal = binary_decimal_dictionary[s0_row]\n",
    "    s0_column_decimal = binary_decimal_dictionary[s0_column]\n",
    "    s0_value = s0[s0_row_decimal][s0_column_decimal]\n",
    "    binary_first_half = get_binary_value(binary_decimal_dictionary, s0_value)\n",
    "    \n",
    "    s1_row = second_half[0]+second_half[-1]\n",
    "    s1_column = second_half[1]+second_half[2]\n",
    "    s1_row_decimal = binary_decimal_dictionary[s1_row]\n",
    "    s1_column_decimal = binary_decimal_dictionary[s1_column]\n",
    "    s1_value = s1[s1_row_decimal][s1_column_decimal]\n",
    "    binary_second_half = get_binary_value(binary_decimal_dictionary, s1_value)\n",
    "    return binary_first_half+binary_second_half\n",
    "\n",
    "\"\"\"Invoking main methods for execution along with\n",
    "1. Key Generation\n",
    "2. Encryption\n",
    "3. Decryption\"\"\"\n",
    "\n",
    "#Key Generation!\n",
    "enc_dec_identifier = str(input(\"Please enter the required value: enc or dec ::\"))\n",
    "input_value = str(input(\"Please enter the 8-bit string to be encrypted or decrypted (in 0's and 1's)::\"))\n",
    "key_value = str(input(\"Please enter the 10-bit key value(in 0's and 1's)::\"))\n",
    "rearranged_string = p_8_10_order(key_value,10)  #Re-arranging the code according to p-10 permutation.\n",
    "split_shift_one_result = split_shift(rearranged_string)\n",
    "k1 = p_8_10_order(split_shift_one_result,8)\n",
    "k1 = k1[1:]\n",
    "split_shift_two_result = split_shift('r'+split_shift_one_result,2)\n",
    "k2 = p_8_10_order(split_shift_two_result,8)\n",
    "k2 = k2[1:]\n",
    "\n",
    "#Encryption & Decryption\n",
    "i_p_arranged_order = input_encryption('i_p',input_value) #Pass input as parameter\n",
    "e_p_arranged_order = input_encryption('e_p', i_p_arranged_order[4:])\n",
    "if enc_dec_identifier == 'enc':\n",
    "    xor_value = xor_with_value(e_p_arranged_order, k1) #K1 to be passed as parameter\n",
    "else:\n",
    "    xor_value = xor_with_value(e_p_arranged_order, k2)\n",
    "division_result = divide_into_bits_s0_s1_mapping(xor_value)\n",
    "p4_result = input_encryption(arrangement = 'p_4',input_key =division_result)\n",
    "prefinal_xored_value=xor_with_value(p4_result, i_p_arranged_order[0:4])\n",
    "\n",
    "#Swapping happens here!!!\n",
    "\n",
    "e_p_arranged_order = input_encryption('e_p',prefinal_xored_value)\n",
    "if enc_dec_identifier == 'enc':\n",
    "    xor_value_post_switch = xor_with_value(e_p_arranged_order, k2) #K2 to be passed as parameter\n",
    "else:\n",
    "    xor_value_post_switch = xor_with_value(e_p_arranged_order, k1)\n",
    "division_result_post_switch = divide_into_bits_s0_s1_mapping(xor_value_post_switch)\n",
    "p4_result_post_switch = input_encryption(arrangement = 'p_4',input_key = division_result_post_switch)\n",
    "xored_fin_value = xor_with_value(p4_result_post_switch,i_p_arranged_order[4:] )\n",
    "penultimate_result = xored_fin_value+prefinal_xored_value\n",
    "ip_inverse_result = input_encryption('i_p_inverse',penultimate_result)\n",
    "if enc_dec_identifier == 'enc':\n",
    "    print(\"Cipher Text is::\",ip_inverse_result)\n",
    "else:\n",
    "    print(\"Decrypted Cipher text is::\",ip_inverse_result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8ec537f7",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6ff0ca20",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
